<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <title>SpawnConfig por Grid</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        font-family: system-ui;
      }
      html,
      body {
        height: 100%;
        display: flex;
      }
      #sidebar {
        width: 260px;
        background: #242424;
        color: #e0e0e0;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      label,
      button {
        display: block;
        padding: 8px;
        text-align: center;
        cursor: pointer;
        background: #333;
        border: 1px solid #444;
        color: inherit;
      }
      input,
      button {
        width: 100%;
      }
      #canvas {
        flex: 1;
        image-rendering: pixelated;
      }
      #status {
        font-size: 0.9rem;
        margin-top: 8px;
      }
    </style>
  </head>
  <body>
    <div id="sidebar">
      <label>
        Carregar Máscara <input type="file" id="maskFile" accept="image/*"
      /></label>
      <label>
        Largura da célula (px)<input
          id="tileW"
          type="number"
          value="10"
          min="1"
      /></label>
      <label>
        Altura da célula (px)<input id="tileH" type="number" value="10" min="1"
      /></label>
      <button id="export">Exportar SpawnConfig</button>
      <div id="status">Nenhuma máscara carregada.</div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
      (() => {
        const MIN_OCCUPANCY = 0.3; // 30 % de pixels opacos para considerar a célula sólida

        const maskFile = document.getElementById("maskFile"),
          tileW = document.getElementById("tileW"),
          tileH = document.getElementById("tileH"),
          exportBt = document.getElementById("export"),
          status = document.getElementById("status"),
          cvs = document.getElementById("canvas"),
          ctx = cvs.getContext("2d");

        let imgW, imgH, imgData;

        /* ----------- carrega a imagem ----------- */
        maskFile.onchange = async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const img = new Image();
          img.src = URL.createObjectURL(file);
          await img.decode();

          imgW = img.width;
          imgH = img.height;
          cvs.width = imgW;
          cvs.height = imgH;
          ctx.clearRect(0, 0, imgW, imgH);
          ctx.drawImage(img, 0, 0);

          const off = new OffscreenCanvas(imgW, imgH);
          off.getContext("2d").drawImage(img, 0, 0);
          imgData = off.getContext("2d").getImageData(0, 0, imgW, imgH);

          status.textContent = `Máscara carregada: ${imgW}×${imgH}px`;
        };

        /* ----------- gera & exporta ----------- */
        exportBt.onclick = () => {
          if (!imgData) return alert("Carregue a máscara primeiro.");

          const w = +tileW.value || 10,
            h = +tileH.value || 10,
            cols = Math.ceil(imgW / w),
            rows = Math.ceil(imgH / h);

          /* mapeia ocupação de células */
          const solid = Array.from({ length: rows }, () =>
            Array(cols).fill(false)
          );
          const visited = Array.from({ length: rows }, () =>
            Array(cols).fill(false)
          );

          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              const x0 = c * w,
                y0 = r * h,
                lim = w * h,
                limOcc = lim * MIN_OCCUPANCY;
              let occ = 0;
              for (let y = y0; y < y0 + h && y < imgH; y++) {
                for (let x = x0; x < x0 + w && x < imgW; x++) {
                  if (imgData.data[(y * imgW + x) * 4 + 3] > 0)
                    if (++occ >= limOcc) {
                      solid[r][c] = true;
                      y = y0 + h;
                      break;
                    }
                }
              }
            }
          }

          /* BFS — regiões conectadas */
          const dirs = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
          ];
          const regions = [],
            allCells = [];

          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              if (!solid[r][c] || visited[r][c]) continue;

              const queue = [[r, c]];
              visited[r][c] = true;
              const cells = [];
              while (queue.length) {
                const [ry, cx] = queue.pop();
                cells.push({ x: cx * w, y: ry * h, w, h });
                allCells.push(cells[cells.length - 1]);

                dirs.forEach(([dy, dx]) => {
                  const ny = ry + dy,
                    nx = cx + dx;
                  if (ny < 0 || ny >= rows || nx < 0 || nx >= cols) return;
                  if (!solid[ny][nx] || visited[ny][nx]) return;
                  visited[ny][nx] = true;
                  queue.push([ny, nx]);
                });
              }
              regions.push(cells);
            }
          }

          /* DEBUG – desenha para conferência */
          ctx.clearRect(0, 0, imgW, imgH);
          ctx.strokeStyle = "#0f0";
          ctx.lineWidth = 1;
          regions.forEach((cells) =>
            cells.forEach((c) => ctx.strokeRect(c.x + 0.5, c.y + 0.5, w, h))
          );

          status.textContent = `Regiões:${regions.length}  |  Células:${allCells.length}`;

          /* monta JSON */
          const cfg = {
            maskW: imgW, // largura original da máscara (sem margem)
            maskH: imgH, // altura original da máscara
            cellW: w, // tamanho da célula (px)
            cellH: h,
            regions: regions.map((cells) => ({ cells, npcs: [] })),
          };

          const blob = new Blob([JSON.stringify(cfg, null, 2)], {
            type: "application/json",
          });
          Object.assign(document.createElement("a"), {
            href: URL.createObjectURL(blob),
            download: "spawnConfig.json",
          }).click();
        };
      })();
    </script>
  </body>
</html>
